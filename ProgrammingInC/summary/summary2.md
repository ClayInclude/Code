# 第2章 基础知识

* [1.1 程序设计](#11-程序设计)

---

* [1.2 高级编程语言](#12-高级编程语言)

---

* [1.3 操作系统](#13-操作系统)

---

* [1.4 编译程序](#14-编译程序)

---

* [1.5 集成开发环境](#15-集成开发环境)

---

* [1.6 解释型语言](#16-解释型语言)

---

## 1.1 程序设计

1. >从本质上讲，**计算机** 实际上是一种相当 **死板的装置** ，它仅仅能够 **按照人们提供给它的指令运行** 。
2. >计算机系统 **能够执行的基本指令的集合** ，通常称为该计算机的 **指令集** 。
3. >计算机程序，实际上也就是 **解决某个具体问题的计算机指令集合** 。
4. >解决某个具体问题的方法被称为 **算法** 。

---

## 1.2 高级编程语言

1. >最早的计算机只能理解 **二进制** 形式的指令。
2. >这些指令通常直接操作 **内存的某个地址** 。
3. >这种形式的指令被称为 **机器语言** 。
4. >**汇编语言** 使用的符号与计算机的二进制指令实际上是 **一一对应** 的。因此，**汇编语言被看作是低级语言** 。
5. >为了使用低级语言编写程序，程序员们必须学习某个特定的 **计算机系统的指令集** 。
6. >由于不同的计算机系统，其指令集常常是不同的，因此必须使用 **低级语言编写的程序不具备可移植性** 。
7. >为了 **克服低级语言的缺点，人们发明了高级语言** 。
8. >高级语言通常有一套 **特定的语法** ，这个语法与具体的计算机系统无关。因此用高级语言书写的程序，可以 **独立于具体的计算机系统** 。
9. >为了支持某种高级语言，人们需要针对特定计算机系统开发一个特殊的程序，该程序 **将高级语言编写的程序翻译为特定计算机系统能够理解的机器指令** 。这种计算机程序被称为 **编译器** 。

---

## 1.3 操作系统

1. >**操作系统** 就是控制计算机系统所有的操作的程序。
2. > *$Unix$* 操作系统最早由 **贝尔实验室** 研发。
3. > *$Unix$* 操作系统可以运行在 **多种计算机系统** 上，如 *$Linux$* 或者 *$Mac OS$* 。
4. > *$Unix$* 的开发主要使用了 **高级语言C** ，而且在开发这个操作系统时，它的设计者使它尽量 **独立于底层硬件环境** ，因此 *$Unix$* 就可以相对轻松地 **移植** 到多种计算机系统中。

---

## 1.4 编译程序

1. >编译器也是一个程序，它可以 **分析使用高级语言编写的程序** ，然后把它 **翻译成特定的计算机系统能够执行的指令** 。
2. >我们通常用 **文本编译器** 把C语言编写的程序 **输入** 到计算机系统的文件当中。
3. >使用文本编译器生成的文件包含了C语言程序的原始形式，因此通常称为 **源文件** 。程序一旦输入到源文件中，我们就可以着手来 **编译** 它了。
4. >为了开始 **编译输入的源文件** ，我们需要让计算机执行特定的命令。
5. >在编译的第一阶段，编译器首先 **检查源程序的每一条语句** ，看它是否 **符合语言的语法和词法** 。如果编译器在这个阶段首先发现了错误，便会将这些错误报告给用户，然后停止运行，程序员必须使用文本编辑器改正这些错误，并重新编译。
6. >当程序中所有的语法和语义错误都被改正以后，编译器就会 **把高级语言编写的源程序翻译为较低级的形式** 。
7. >在绝大多数计算机系统上，这些 **高级程序通常首先被翻译为汇编语言程序** ，这些 **汇编语言程序完成的功能与高级语言程序相同** 。
8. >源程序被翻译为对应的汇编语言程序之后，编译器还需要将这些汇编语言程序翻译为 **实际的机器指令** 。
9. >汇编器读入编译器生成的汇编语言程序，将其翻译为 **二进制格式** 的代码，这种代码被称为 **目标码** 。
10. >汇编器将这些生成的 **目标码保存在目标文件** 中。
11. >生成目标文件以后，我们就可以进行下一个步骤--**“连接”** 了。
12. >连接的主要作用是 **将目标代码转化为具体的计算机系统上实际的可执行程序** 。
13. >在 *$Unix$* 环境中，连接器生成的可执行文件，其默认文件名是 **a.out** 。
14. >在 *$Windows$* 系统中，这个可执行文件的名字通常与源文件名字相同，但是 **其文件名的结尾是.exe** 。
15. >为了运行生成的可执行文件，我们只需要简单在系统命令行中输入下面的命令 **a.out** ，这个命令 **将可执行文件装入计算机的内存，然后开始运行其中的指令** 。
16. >当程序开始运行后，计算机将会 **按顺序** 执行程序中的指令。
17. >程序运行的结果通常输出到一个 **窗口** 中，这个窗口被称为 **终端** ，有时程序也可以 **直接输出到系统文件中** 。
18. >在调试的过程中，如果程序的结果不正确，那么我们需要回过头来重新分析程序，**排除程序逻辑错误的过程称为“调试”**。
19. >在调试过程中，我们通常需要 **修改源文件** ，这时我们还需要 **重新编译** 、 **连接** ，以 **生成可执行程序** 。这个调试过程不断重复，直到程序产生我们所需要的结果。

---

## 1.5 集成开发环境

1. >在现代软件开发过程中，编辑、编译、运行和调试过程通常 **由单个应用程序控制** ，这个应用程序被称作 **集成开发环境（IDE）** 。
2. >在 *$Mac OS X$* 系统中，*$Code Warrior$* 和 *$XCode$* 是两个很流行的IDE。
3. >在 *$Windows$* 系统中， *$Microsoft Visual Studio$* 是一个非常受欢迎的IDE。
4. > *$Kylix$* 则是 *$Linux$* 下非常热门的 *$IDE$* 。

---

## 1.6 解释型语言

1. >还有另外一种方法，可以 **分析、执行使用高级语言编写的程序** ，这种方法不是编译程序，而是 **对程序进行解释执行** ，执行所需的程序被称为 **解释器** 。
2. >解释器 **不需要独立的编译、连接过程** ，它 **一遍分析源程序，一遍执行这些程序** 。
3. >当采用解释执行方法的时候，程序调试起来要容易一些，但是 **解释执行的程序通常比编译执行的程序要慢** ，因为编译型语言在执行程序之前，已经预先将程序中的指令翻译成机器指令。
4. > *$Basic$* 和 *$Java$* 是 **解释型高级语言** 的两个例子。
5. > *$Unix$* 的 *$shell$* 和 *$Python$* 也是 **解释型的语言** 。

---
